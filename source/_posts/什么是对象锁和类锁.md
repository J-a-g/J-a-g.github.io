---
title: 什么是对象锁和类锁
date: 2020-03-05 19:30:20
catalog:    true
header-img: "post-bg-unix-linux.jpg"
tags:
    - Java
---

## 名词解释

**对象锁**
类声明后，我们可以 new 出来很多的实例对象。这时候，每个实例在 JVM 中都有自己的引用地址和堆内存空间，这时候，我们就认为这些实例都是独立的个体，很显然，在实例上加的锁和其他的实例就没有关系，互不影响了。
**类锁** 
类锁是加载类上的，而类信息是存在 JVM 方法区的，并且整个 JVM 只有一份，方法区又是所有线程共享的，所以类锁是所有线程共享的。

## synchronized的使用

在java代码中使用synchronized可是使用在代码块和方法中，根据Synchronized用的位置可以有这些使用场景：
![java-javascript](2615789-08f16aeac7e0977d.webp)
<small class="img-hint">synchronized的使用场景</small>
> 下面会根据上述的几种使用场景，通过代码测试来说明对象锁和类锁的区别

## 对象锁

**1.锁住非静态变量**
非静态变量是实例自身变量，不会与其他实例共享，所以锁住实体内声明的非静态变量可以实现对象锁。锁住同一个变量的方法块共享同一把锁。
```js
private String lock = "";

    /**
     * 锁住非静态变量
     * @throws InterruptedException
     */
    public void lockString() throws InterruptedException {
        synchronized (lock) {
            System.out.println("线程名：" + Thread.currentThread().getName() + " 线程id:" + Thread.currentThread().getId()+ " " + DateFormat.getTimeInstance().format(new Date()));
            Thread.sleep(5000);
        }
    }

```

**2.锁住this对象**
this 指的是当前对象实例本身，所以，所有使用 synchronized(this) 方式的方法都共享同一把锁。
```js
    /**
     * 锁住this对象
     * @throws InterruptedException
     */
    public void lockThis() throws InterruptedException {
        synchronized (this) {
            System.out.println("线程名：" + Thread.currentThread().getName() + " 线程id:" + Thread.currentThread().getId()+ " " + DateFormat.getTimeInstance().format(new Date()));
            Thread.sleep(5000);
        }
    }
```

**3.锁住非静态方法**
最简单、最直观的一种方式，直接加在方法返回类型前。
```js
    /**
     * 锁住非静态方法
     * @throws InterruptedException
     */
    public synchronized void lockMethod() throws InterruptedException {
        System.out.println("线程名：" + Thread.currentThread().getName() + " 线程id:" + Thread.currentThread().getId()+ " " + DateFormat.getTimeInstance().format(new Date()));
        Thread.sleep(5000);
    }
```

下面看一下测试代码，创建5个线程，每个线程中都创建一个ObjectLock对象:
```js
public static void main(String res[]) {
        for (int i = 0; i < 5; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        ObjectLock objectLock = new ObjectLock();
                        objectLock.lockThis();//也可以测试一下其他方法
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
```
再看一下打印出来的日志:
```js
线程名：Thread-4 线程id:14 23:27:26
线程名：Thread-0 线程id:10 23:27:26
线程名：Thread-2 线程id:12 23:27:26
线程名：Thread-3 线程id:13 23:27:26
线程名：Thread-1 线程id:11 23:27:26
```
发现5个ObjectLock对象的lockThis()几乎是同时调用的，相互之间并没有受到印象。`接着我们修改一下测试代码，创建5个线程，但是只有一个ObjectLock对象:`
```js
public static void main(String res[]) {
        ObjectLock objectLock = new ObjectLock();
        for (int i = 0; i < 5; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        objectLock.lockThis();//也可以测试一下其他方法
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
```
再看一下打印出来的日志:
```js
线程名：Thread-0 线程id:10 23:39:38
线程名：Thread-4 线程id:14 23:39:43
线程名：Thread-3 线程id:13 23:39:48
线程名：Thread-2 线程id:12 23:39:53
线程名：Thread-1 线程id:11 23:39:58
```
> 结论：使用对象锁的情况，只有使用同一实例的线程才会受锁的影响，多个实例调用同一方法也不会受影响。

## 类锁

**1.锁住静态方法**
因为静态方法同样也是存在方法区的并且整个 JVM 只有一份，所以加在静态方法上可以达到类锁的目的。
```js
    /**
     * 锁住静态方法
     * @throws InterruptedException
     */
    public static synchronized void lockStaticMethod() throws InterruptedException {
        System.out.println("线程名：" + Thread.currentThread().getName() + " 线程id:" + Thread.currentThread().getId()+ " " + DateFormat.getTimeInstance().format(new Date()));
        Thread.sleep(3000);
    }
```

**2.锁住.class**
对当前类的 .class 属性加锁，可以实现类锁。
```js
    /**
     * 锁住.class
     * @throws InterruptedException
     */
    public void lockClass() throws InterruptedException {
        synchronized (ClassLock.class){
            System.out.println("线程名：" + Thread.currentThread().getName() + " 线程id:" + Thread.currentThread().getId()+ " " + DateFormat.getTimeInstance().format(new Date()));
            Thread.sleep(3000);
        }
    }
```

**3.锁住静态变量**
```js
    private static String lock = "";

    /**
     * 锁住静态变量
     * @throws InterruptedException
     */
    public void lockStaticString() throws InterruptedException {
        synchronized (lock){
            System.out.println("线程名：" + Thread.currentThread().getName() + " 线程id:" + Thread.currentThread().getId()+ " " + DateFormat.getTimeInstance().format(new Date()));
            Thread.sleep(3000);
        }
    }
```

下面看一下测试代码，同样是创建5个线程，并创建5个对象：
```js
    public static void main(String res[]) {
        for (int i = 0; i < 5; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    ClassLock classLock = new ClassLock();
                    try {
                        classLock.lockClass();//可以测试一下其他方式
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
```
再看一下日志：
```js 
线程名：Thread-0 线程id:10 23:48:22
线程名：Thread-4 线程id:14 23:48:25
线程名：Thread-3 线程id:13 23:48:28
线程名：Thread-2 线程id:12 23:48:31
线程名：Thread-1 线程id:11 23:48:34
```
> 结论：类锁是所有线程共享的锁，所以同一时刻，只能有一个线程使用加了锁的方法或方法体，不管是不是同一个实例。

