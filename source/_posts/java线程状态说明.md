---
title: java线程状态说明
date: 2020-07-20 22:14:28
catalog:    true
header-img: "post-bg-unix-linux.jpg"
tags:
    - Java
    - Android
---

## 线程状态说明

![java-javascript](运行状态.png)
<small class="img-hint">线程状态说明图</small>
线程状态从大的方面来说，可归结为`初始状态、可运行状态、不可运行状态、消亡状态`，具体细分为上图的7个状态

**1）**线程实现有两种方式，一是继承Thread类，二是实现Runnable接口，但不管怎么样，当我们new了Thread实例后，线程就进入了`初始状态`
**2）**当该对象调用了start()方法，就进入了`可运行状态`
**3）**进入可运行状态后，当该对象被操作系统选中，`获得cpu时间片`就会进入`运行状态`
**4）**run()方法或者main()方法结束后，线程就进入`终止状态`
**5）**当线程调用了自身的sleep()方法或其他线程的join()方法，就会进入`阻塞状态`,**（该状态虽停止当前线程，但并不释放所占有的资源）**。当sleep()结束或join()结束后，该线程进入`可运行状态`，继续等待os分配时间片
**6）**当线程刚进入可运行状态（注意，还没运行），发现将要调用的资源被锁住（synchronized、lock），将会立即进入`锁池状态`，等待获得锁标记（这时的锁池里也许已经有了其他线程在等待获取锁标记，这是他们处于`队列状态，即先到先得`），一旦线程获得锁标记后，就转入`可运行状态`,等待os分配cpu时间片
**7）**当线程调用wait（）方法后会进入`等待队列`**（进入这个状态会释放所占有的所有资源，与阻塞状态不同）**，进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒（由于notify（）只是唤醒一个线程，但我们由于不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒，因此在实际使用时，一般都用notifyAll（）方法，唤醒所有线程），线程被唤醒后会进入`锁池`,等待获取锁标记
**8）**当线程调用了stop（）方法，即可使线程进入`消亡状态`,但是由于stop（）方法是不安全的，不鼓励使用，可以通过run（）方法里的条件变通实现线程的stop

## sleep()与wait()

**1）**sleep()方法是Thread的静态方法，而wait()是Object实例方法
**2）**wait()方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而sleep()方法没有这个限制可以在任何地方使用。另外，wait（）方法会释放所占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出cpu并不会释放对象锁
**3）**sleep（）方法在休眠时间达到后如果再次获得cpu时间片就会继续执行，而wait（）方法必须等待Object.notify/Object.notifyAll通知后，才会离开等待池，并且再次获得cpu时间片才会继续执行