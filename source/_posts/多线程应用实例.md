---
title: 多线程应用实例
date: 2020-07-30 23:45:47
catalog:    true
header-img: "post-bg-unix-linux.jpg"
tags:
    - Java
    - Android
---

>阅读这篇文章前，要先确定了解线程几种状态，可以阅读{% post_link java线程状态说明 《java线程状态说明》 %}

## 多线程之百米赛跑

>简单描述：使用多线程实现一个运动员百米扫跑的实际场景，并在最后公布运动员成绩

##### CountDownLatch

实现多线程百米赛跑我将使用到上面这个类，这里先简单介绍一下这个类**CountDownLatch类**可以使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行王弼后，计数器的值-1，当计数器的指为0时，表示所有线程都执行完毕，然后再闭锁上等待线程就可以恢复工作了

//参数count为计数值
**public CountDownLatch(int count);**

//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
**public void await() throws java.lang.InterruptedException;**

//和await()方法雷士，只不过等待一定的时间后count值还没变为0的话，就会继续执行
**public boolean await(long timeout, java.util.concurrent.TimeUnit unit) throws java.lang.InterruptedException;**

//计数值-1
**public void countDown();**

##### CountDownLatch和CyclicBarrier区别

* CountDownLatch是一个计数器，线程完成一个记录一个，计数器递减，只能使用一次。
* CyclicBarrier的计数器更像是一个阀门，需要所有线程都到达，然后继续执行，计数器递增，提供reset功能，可以多次使用。

##### 代码

```js
//运动员
public class Runner implements Callable<Integer>{
	
	private CountDownLatch cdl_begin, cdl_end;
	private int No;
	
	public Runner(Integer No, CountDownLatch begin, CountDownLatch end) {
		// TODO Auto-generated constructor stub
		this.No = No;
		this.cdl_begin = begin;
		this.cdl_end = end;
	}

	@Override
	public Integer call() throws Exception {
		// TODO Auto-generated method stub
		int score = new Random().nextInt(15);
		cdl_begin.await();//运动员线程已经启动，在此挂起，等到后续起跑通知
		TimeUnit.SECONDS.sleep(score);
		cdl_end.countDown();//该运动员线程执行完成后，也就是已经跑到终点，cdl_end计数器-1，当cdl_end计数值变为0，比赛结束开始统计成绩
		System.out.println("No:" + No + "号，到达终点，成绩：" + score +"s");
		return score;
	}
}


	public static void main(String[] args) {
		try {
			int persons = 8;
			CountDownLatch beginCountDownLatch = new CountDownLatch(1);
			CountDownLatch endCountDownLatch = new CountDownLatch(persons);

			ExecutorService eService = Executors.newFixedThreadPool(persons);
			List<Future<Integer>> futures = new ArrayList<Future<Integer>>();
			for (int i = 0; i < persons; i++) {
				futures.add(eService.submit(new Runner(i, beginCountDownLatch, endCountDownLatch)));
			}
			
			beginCountDownLatch.countDown();//发令枪响，运动员线程开始起跑，运行后续的代码
			System.out.println("比赛开始");
			endCountDownLatch.await();//等待最后一名运动员线程执行完成
			System.out.println("比赛结束,开始统计成绩");
			
			for (Future<Integer> f : futures) {
				System.out.println("成绩：" + f.get());
			}
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ExecutionException e) {
			// TODO: handle exception
			e.printStackTrace();
		}
	}

```

## 多线程交替打印0-100的值

>如有3个线程，线程名分别是A,B,C,通过这三个线程交替打印出0-100的值，如A:0, B:1, C:2, A:3, B:4, C:5.......

下面这个示例是通过使用synchronized, wait和notifyAll，来实现上述的功能

```js
public class MyRunnable implements Runnable{
	private static int num = 0;
	int index = 0;
	String name = "";
	private static Object lock = new Object();
	
	public MyRunnable(int index, String name) {
		this.index = index;
		this.name = name;
	}
	
	@Override
	public void run() {
		while (num <= 100) {
			// 上锁当前对象
			synchronized (lock) {
				// 唤醒另一个线程
				lock.notifyAll();
				if (num == 101) {
					return;
				}
				if (num % 3 == index) {
					System.out.println("index:" + index + " name:" + name + " num:" + num);
					num++;
				}
				try {
					if (num == 101) {
						lock.notifyAll();
						return;
					} else {
						// 释放掉锁
						lock.wait();
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}
	}

}




	public static void main(String[] args) {
		
		Thread t1 = new Thread(new MyRunnable(0, "A"));
		Thread t2 = new Thread(new MyRunnable(1, "B"));
		Thread t3 = new Thread(new MyRunnable(2, "C"));
		t1.start();
		t2.start();
		t3.start();
	}
```

<!-- 
5种方法
使用synchronized, wait和notifyAll
使用Lock->ReentrantLock 和 state标志
使用Lock->ReentrantLock 和Condition（await 、signal、signalAll）
使用Semaphore
使用AtomicInteger
 -->