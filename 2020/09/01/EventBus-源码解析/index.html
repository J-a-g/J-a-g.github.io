<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          EventBus 源码解析 - JAG的博客 | JAG&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://j-a-g.github.io/2020/09/01/EventBus-源码解析/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">JAG&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://j-a-g.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('post-bg-unix-linux.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                          <a class="tag" href="/tags/#Android" title="Android">Android</a>
                        
                    </div>
                    <h1>EventBus 源码解析</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Chengjian Su on
                        2020-09-01
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/greenrobot/EventBus">EventBus</a>是Android上的以发布\订阅事件为核心的库。事件 (event) 通过 post() 发送到总线，然后再分发到匹配事件类型的订阅者 (subscribers) 。订阅者只有在总线中注册 (register) 了才能收到事件，注销 (unrigister) 之后就收不到任何事件了。事件方法必须带有 Subscribe 的注解，必须是 public ，没有返回类型 void 并且只能有一个参数。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>添加依赖到 Gradle：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.greenrobot:eventbus:3.2.0&#x27;</span></span><br></pre></td></tr></table></figure>
<p>1.定义事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageEvent</span> </span>&#123; <span class="comment">/* Additional fields if needed */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>2.准备订阅者<br>声明并用<code>Subscribe</code>注释修饰订阅方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Subscribe(threadMode = ThreadMode.MAIN)  </span><br><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">onMessageEvent</span>(<span class="params">MessageEvent event</span>)</span> &#123;<span class="comment">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>订阅者同时需要在总线上注册和注销自己。只有当订阅者注册了才能接收到事件。在Android中，通常与<code>Activity</code>和<code>Fragment</code>的生命周期绑定在一起。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">onStart</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStart();</span><br><span class="line">    EventBus.getDefault().register(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">onStop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onStop();</span><br><span class="line">    EventBus.getDefault().unregister(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.发送事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> MessageEvent());</span><br></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>源码解析会从创建对象、准备订阅者、注册、反注册、发送消息几个步骤进行解析</p>
<h2 id="创建EventBus对象"><a href="#创建EventBus对象" class="headerlink" title="创建EventBus对象"></a>创建EventBus对象</h2><p>先看看<code>getDefault()</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> volatile EventBus defaultInstance;</span><br><span class="line"><span class="comment">/** Convenience singleton for apps using a process-wide EventBus instance. */</span></span><br><span class="line">public <span class="keyword">static</span> EventBus <span class="function"><span class="title">getDefault</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    EventBus instance = defaultInstance;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        synchronized (EventBus.class) &#123;</span><br><span class="line">            instance = EventBus.defaultInstance;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                instance = EventBus.defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单例设计模式，用到了double check。再看看<code>EventBus</code>的构造方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</span></span><br><span class="line"><span class="comment">  * central bus, consider &#123;<span class="doctag">@link </span>#getDefault()&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> public <span class="function"><span class="title">EventBus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>(DEFAULT_BUILDER);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>虽然采用了单例设计模式，但是构造函数还是<code>public</code>，这样的设计是因为不仅仅可以只有一条总线，还可以有其他的线 (bus) ，订阅者可以注册到不同的线上的<code>EventBus</code>，通过不同的<code>EventBus</code>实例来发送数据，不同的<code>EventBus</code>是相互隔离开的，订阅者都只会收到注册到该线上事件。</p>
<p>再看看这个 this(DEFAULT_BUILDER) :</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">EventBus</span>(<span class="params">EventBusBuilder builder</span>)</span> &#123;</span><br><span class="line">    logger = builder.getLogger();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护3个重要的Map</span></span><br><span class="line">    <span class="comment">//key为event，value为subscriber列表，这个map就是这个事件有多少的订阅者，也就是事件对应的订阅者</span></span><br><span class="line">    <span class="comment">//key为订阅方法的参数类型，value为Subscription列表，这个map就是这个事件有多少的订阅者，也就是事件对应的订阅者</span></span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//key为subscriber，value为event列表，这个map就是这个订阅者有多少的事件，也就是订阅者订阅的事件列表</span></span><br><span class="line">    <span class="comment">//key为订阅类，value为订阅类中订阅方法参数类型集合，这个map就是这个订阅者有多少的事件，也就是订阅者订阅的事件列表</span></span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//粘性事件</span></span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    mainThreadSupport = builder.getMainThreadSupport();</span><br><span class="line">    <span class="comment">//MainThread的poster</span></span><br><span class="line">    mainThreadPoster = mainThreadSupport != <span class="literal">null</span> ? mainThreadSupport.createPoster(<span class="built_in">this</span>) : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//Backgroud的poster</span></span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//Async的poster</span></span><br><span class="line">    <span class="comment">//订阅者方法寻找类，默认情况下参数是(null, false, false)</span></span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="built_in">this</span>);</span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="literal">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明一下上面的3个Map:<br><strong>subscriptionsByEventType：</strong>是以<code>event</code>为key，<code>subscriber</code>列表为value，当发送<code>event</code>的时候，都是去这里找对应的订阅者。<br><strong>typesBySubscriber：</strong>是以<code>subscriber</code>为key，<code>event</code>列表为<code>value</code>，当<code>register()</code>和<code>unregister()</code>的时候都是操作这个<code>map</code>，同时对<code>subscriptionsByEventType</code>进行对用操作。<br><strong>stickyEvents：</strong>维护的是粘性事件，粘性事件也就是当<code>event</code>发送出去之后再注册粘性事件的话，该粘性事件也能收到之前发送出去的<code>event</code>。</p>
<p>这里运用到了<code>builder</code>设计模式，那么来看看这个<code>Builder</code>中有哪些参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">EventBusBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    private final <span class="keyword">static</span> ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">//当调用事件处理函数异常时是否打印异常信息</span></span><br><span class="line">    boolean logSubscriberExceptions = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//当没有订阅者订阅该事件时是否打印日志</span></span><br><span class="line">    boolean logNoSubscriberMessages = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//当调用事件处理函数异常时是否发送 SubscriberExceptionEvent 事件</span></span><br><span class="line">    boolean sendSubscriberExceptionEvent = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//当没有事件处理函数对事件处理时是否发送 NoSubscriberEvent 事件</span></span><br><span class="line">    boolean sendNoSubscriberEvent = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//是否要抛出异常，建议debug开启</span></span><br><span class="line">    boolean throwSubscriberException;</span><br><span class="line">    <span class="comment">//与event有继承关系的是否需要发送</span></span><br><span class="line">    boolean eventInheritance = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">////是否忽略生成的索引(SubscriberInfoIndex)</span></span><br><span class="line">    boolean ignoreGeneratedIndex;</span><br><span class="line">    <span class="comment">//是否严格的方法名校验</span></span><br><span class="line">    boolean strictMethodVerification;</span><br><span class="line">    <span class="comment">//线程池，async 和 background 的事件会用到</span></span><br><span class="line">    ExecutorService executorService = DEFAULT_EXECUTOR_SERVICE;</span><br><span class="line">    <span class="comment">//当注册的时候会进行方法名的校验(EventBus3之前方法名必须以onEvent开头)，而这个列表是不参加校验的类的列表(EventBus3之后就没用这个参数了)</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; skipMethodVerificationForClasses;</span><br><span class="line">    <span class="comment">//维护着由EventBus生成的索引(SubscriberInfoIndex)</span></span><br><span class="line">    List&lt;SubscriberInfoIndex&gt; subscriberInfoIndexes;</span><br><span class="line">    Logger logger;</span><br><span class="line">    MainThreadSupport mainThreadSupport;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">EventBusBuilder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="准备订阅者"><a href="#准备订阅者" class="headerlink" title="准备订阅者"></a>准备订阅者</h2><p>先看一下<code>Subscribe</code>注释</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Documented</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">public @interface Subscribe &#123;</span><br><span class="line">    ThreadMode threadMode() <span class="keyword">default</span> ThreadMode.POSTING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If true, delivers the most recent sticky event (posted with</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link </span>EventBus#postSticky(Object)&#125;) to this subscriber (if event available).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    boolean sticky() <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Subscriber priority to influence the order of event delivery.</span></span><br><span class="line"><span class="comment">     * Within the same delivery thread (&#123;<span class="doctag">@link </span>ThreadMode&#125;), higher priority subscribers will receive events before</span></span><br><span class="line"><span class="comment">     * others with a lower priority. The default priority is 0. Note: the priority does *NOT* affect the order of</span></span><br><span class="line"><span class="comment">     * delivery among subscribers with different &#123;<span class="doctag">@link </span>ThreadMode&#125;s! */</span></span><br><span class="line">    int priority() <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ThreadMode</code>是枚举：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public enum ThreadMode &#123;</span><br><span class="line">    POSTING,<span class="comment">//post的时候是哪个线程订阅者就在哪个线程接收到事件</span></span><br><span class="line">    MAIN,<span class="comment">//订阅者在主线程接收到事件</span></span><br><span class="line">    BACKGROUND,<span class="comment">//订阅者在主线程接收到消息，如果post的时候不是在主线程的话，那么订阅者会在post的时候那个线程接收到事件。适合密集或者耗时少的事件。</span></span><br><span class="line">    ASYNC<span class="comment">//订阅者会在不同的子线程中收到事件。适合操作耗时的事件。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册订阅者"><a href="#注册订阅者" class="headerlink" title="注册订阅者"></a>注册订阅者</h2><p>先看代码，这部分代码比较少,但是分析时也分开两个步骤进行分析</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">register</span>(<span class="params"><span class="built_in">Object</span> subscriber</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//拿到订阅者的class</span></span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        <span class="comment">//通过class去找到订阅方法</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        <span class="comment">//blabla...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是subscriberMethodFinder.findSubscriberMethods(subscriberClass)，看一下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SubscriberMethod&gt; <span class="function"><span class="title">findSubscriberMethods</span>(<span class="params">Class&lt;?&gt; subscriberClass</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//先从METHOD_CACHE中查看是否已经有这个订阅者了</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">        <span class="comment">//有了的话直接把订阅者的方法返回</span></span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ignoreGeneratedIndex默认是false</span></span><br><span class="line">        <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">            subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Subscriber &quot;</span> + subscriberClass</span><br><span class="line">                    + <span class="string">&quot; and its super classes have no public methods with the @Subscribe annotation&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//放到缓存当中</span></span><br><span class="line">            METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">            <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在使用<code>EventBus.getDefault()</code>时用的是默认的<code>builder</code>，而当使用<code>EventBusBuilder.installDefaultEventBus()</code>时是设置自己可配置的<code>builder</code>。这里我们先讨论默认情况下的。所以应该走到<code>findUsingInfo(subscriberClass)</code>方法来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; <span class="function"><span class="title">findUsingInfo</span>(<span class="params">Class&lt;?&gt; subscriberClass</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//1.得到一个FindState对象</span></span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        <span class="comment">//blabla..</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看一下<code>FindState</code>是什么，<code>prepareFindState()</code>做了什么 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FindState</span> </span>&#123;</span><br><span class="line">        <span class="comment">//订阅者的方法的列表</span></span><br><span class="line">        final List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//以EventType为key，method为value</span></span><br><span class="line">        final <span class="built_in">Map</span>&lt;Class, <span class="built_in">Object</span>&gt; anyMethodByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//以method的名字生成一个methodKey为key，该method的类(订阅者)为value</span></span><br><span class="line">        final <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建methodKey的StringBuilder</span></span><br><span class="line">        final StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">        <span class="comment">//订阅者</span></span><br><span class="line">        Class&lt;?&gt; subscriberClass;</span><br><span class="line">        <span class="comment">//当前类</span></span><br><span class="line">        Class&lt;?&gt; clazz;</span><br><span class="line">        <span class="comment">//是否跳过父类</span></span><br><span class="line">        boolean skipSuperClasses;</span><br><span class="line">        SubscriberInfo subscriberInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="function"><span class="title">initForSubscriber</span>(<span class="params">Class&lt;?&gt; subscriberClass</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">            skipSuperClasses = <span class="literal">false</span>;</span><br><span class="line">            subscriberInfo = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FindState复用池大小</span></span><br><span class="line">   private <span class="keyword">static</span> final int POOL_SIZE = <span class="number">4</span>;</span><br><span class="line">   <span class="comment">//FindState复用池</span></span><br><span class="line">   private <span class="keyword">static</span> final FindState[] FIND_STATE_POOL = <span class="keyword">new</span> FindState[POOL_SIZE];</span><br><span class="line"></span><br><span class="line">   private FindState <span class="function"><span class="title">prepareFindState</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       synchronized (FIND_STATE_POOL) &#123;</span><br><span class="line">           <span class="comment">//遍历复用池</span></span><br><span class="line">           <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">               FindState state = FIND_STATE_POOL[i];</span><br><span class="line">               <span class="keyword">if</span> (state != <span class="literal">null</span>) &#123;</span><br><span class="line">                   FIND_STATE_POOL[i] = <span class="literal">null</span>;</span><br><span class="line">                   <span class="keyword">return</span> state;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>就是从一个复用池中取<code>FindState</code>对象并返回，继续<code>findUsingInfo(subscriberClass)</code>的流程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; <span class="function"><span class="title">findUsingInfo</span>(<span class="params">Class&lt;?&gt; subscriberClass</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//1.得到一个FindState对象</span></span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        <span class="comment">//2.subscriberClass赋值给findState</span></span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        <span class="comment">//2.findState的当前class不为null</span></span><br><span class="line">        <span class="keyword">while</span> (findState.clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.默认情况下，getSubscriberInfo()返回的是null</span></span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            <span class="comment">//2.那么这个if判断就跳过了</span></span><br><span class="line">            <span class="keyword">if</span> (findState.subscriberInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//2.来到了这里,这个方法重要，在这个方法中找到了哪些是订阅者订阅的方法和事件：</span></span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>findUsingReflectionInSingleClass()</code>很重要，在这个方法中找到了哪些是订阅者订阅的方法和事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这个方法中找到了哪些是订阅者订阅的方法和事件</span></span><br><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">findUsingReflectionInSingleClass</span>(<span class="params">FindState findState</span>)</span> &#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="comment">//通过反射，获取到订阅者的所有方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methods = findState.clazz.getMethods();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LinkageError error) &#123; <span class="comment">// super class of NoClassDefFoundError to be a bit more broad...</span></span><br><span class="line">            <span class="built_in">String</span> msg = <span class="string">&quot;Could not inspect methods of &quot;</span> + findState.clazz.getName();</span><br><span class="line">            <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">                msg += <span class="string">&quot;. Please consider using EventBus annotation processor to avoid reflection.&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                msg += <span class="string">&quot;. Please make this class visible to EventBus annotation processor to avoid reflection.&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(msg, error);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.skipSuperClasses = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">//拿到修饰符(public 、private等)</span></span><br><span class="line">        int modifiers = method.getModifiers();</span><br><span class="line">        <span class="comment">//判断是否是public，是否有需要忽略修饰符</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//获得方法的参数</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="comment">//EventBus只允许订阅方法后面的订阅事件是一个</span></span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//判断该方法是不是被Subcribe的注解修饰着的</span></span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="comment">//确定这是一个订阅方法</span></span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">//通过Annotation去拿一些数据</span></span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        <span class="comment">//添加到subscriberMethods中</span></span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                <span class="built_in">String</span> methodName = method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;@Subscribe method &quot;</span> + methodName +</span><br><span class="line">                        <span class="string">&quot;must have exactly 1 parameter but has &quot;</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            <span class="built_in">String</span> methodName = method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                    <span class="string">&quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法流程是：<br>1.拿到当前<code>class</code>的所有方法<br>2.过滤掉不是<code>public</code>和是<code>abstract、static、bridge、synthetic</code>的方法<br>3.过滤出方法参数只有一个的方法<br>4.过滤出被<code>Subscribe注解</code>修饰的方法<br>5.将<code>method方法</code>和<code>event事件</code>添加到FindState中<br>6.将EventBus关心的<code>method方法、event事件、threadMode、priority、sticky</code>封装成<code>SubscriberMethod</code>对象添加到findState.subscriberMethods列表中</p>
<p>那么再来看看<code>findState.checkAdd(method, eventType)</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>method 订阅方法的Method对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>eventType 订阅事件的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return </span>true:该订阅方法允许添加至findState.subscriberMethods中   </span></span><br><span class="line"><span class="comment"> *             false:该订阅方法不需添加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">boolean <span class="function"><span class="title">checkAdd</span>(<span class="params">Method method, Class&lt;?&gt; eventType</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Map&lt;Class, Object&gt; anyMethodByEventType，它是FindState的成员变量</span></span><br><span class="line">    <span class="comment">// 这里以订阅的事件类型为key,订阅方法的Method对象为value put进此Map</span></span><br><span class="line">    <span class="built_in">Object</span> existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">    <span class="keyword">if</span> (existing == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若existing为null表示从未订阅过此类型的事件,当然直接返回true</span></span><br><span class="line">        <span class="comment">// 一级检查</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 到这里说明anyMethodByEventType中存在了key为当前订阅事件(eventType)的值</span></span><br><span class="line">        <span class="comment">// existing = Map中以前eventType对应的value</span></span><br><span class="line">        <span class="comment">// 二级检查</span></span><br><span class="line">        <span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">            <span class="comment">// 只会在第一次遇到相同事件类型时先调用checkAddWithMethodSignature</span></span><br><span class="line">            <span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将该事件类型对应的value置位非Method类型</span></span><br><span class="line">            anyMethodByEventType.put(eventType, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查订阅方法是否需要解析为SubscriberMethod对象并添加至集合</span></span><br><span class="line">        <span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法分为了两级检查，首先会检查订阅事件类型在<code>anyMethodByEventType</code>是否存在了，如果不存在，则直接允许将该订阅方法添加至<code>findState.subscriberMethods</code>中，如果存在，则调用<code>checkAddWithMethodSignature()</code>进行方法签名的检查。为什么需要两级呢？因为大多数注册类中的订阅方法，一般都不会同时订阅相同类型的事件，此时便无需调用<code>checkAddWithMethodSignature()</code>了。只有当注册类中的多个订阅方法同时订阅了同一事件类型时，才需要进一步验证。一级检查很简单，所以我们重点来看看二级检查：<code>checkAddWithMethodSignature()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private boolean <span class="function"><span class="title">checkAddWithMethodSignature</span>(<span class="params">Method method, Class&lt;?&gt; eventType</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空methodKeyBuilder中的内容</span></span><br><span class="line">    methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 将方法的名字添加到methodKeyBuilder中</span></span><br><span class="line">    methodKeyBuilder.append(method.getName());</span><br><span class="line">    <span class="comment">// 将 &gt; 符号 和 订阅事件类型全限定名点击到methodKeyBuilder中</span></span><br><span class="line">    methodKeyBuilder.append(<span class="string">&#x27;&gt;&#x27;</span>).append(eventType.getName());</span><br><span class="line">    <span class="comment">// 假设订阅方法:public void methodName(String name);</span></span><br><span class="line">    <span class="comment">// 此时methodKey是这样的格式:methodName&gt;java.lang.String</span></span><br><span class="line">    <span class="built_in">String</span> methodKey = methodKeyBuilder.toString();</span><br><span class="line">    <span class="comment">// 获取订阅方法所在类的类名 例如:class MainActivity</span></span><br><span class="line">    Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">    <span class="comment">// Map&lt;String, Class&gt; subscriberClassByMethodKey，它是FindState的成员</span></span><br><span class="line">    <span class="comment">// key是methodKey(方法名+ &gt; + 参数类型),value是订阅方法所在类的类名</span></span><br><span class="line">    <span class="comment">// methodClassOld是以前在subscriberClassByMethodKey中key为methodKey的value,</span></span><br><span class="line">    <span class="comment">// 如果没有则为null</span></span><br><span class="line">    Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">    <span class="comment">// methodClassOld == null 这个好理解,表示此方法签名从来没存在过,</span></span><br><span class="line">    <span class="comment">// 那当然是返回true</span></span><br><span class="line">    <span class="comment">// 后面一个条件是什么鬼?它判断methodClassOld是否是methodClass自己或它的父类</span></span><br><span class="line">    <span class="keyword">if</span> (methodClassOld == <span class="literal">null</span> || methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        subscriberClassByMethodKey.put(methodKey, methodClassOld);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两级检查主要就是为了不能出现一个订阅者有多个方法订阅的是同一事件的情况。现在回过头来看一下<code>SubscriberMethod</code>这个类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">    final Method method;</span><br><span class="line">    final ThreadMode threadMode;</span><br><span class="line">    final Class&lt;?&gt; eventType;</span><br><span class="line">    final int priority;</span><br><span class="line">    final boolean sticky;</span><br><span class="line">    <span class="comment">/** Used for efficient comparison */</span></span><br><span class="line">    <span class="built_in">String</span> methodString;</span><br><span class="line"></span><br><span class="line">    public <span class="function"><span class="title">SubscriberMethod</span>(<span class="params">Method method, Class&lt;?&gt; eventType, ThreadMode threadMode, int priority, boolean sticky</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">        <span class="built_in">this</span>.threadMode = threadMode;</span><br><span class="line">        <span class="built_in">this</span>.eventType = eventType;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">        <span class="built_in">this</span>.sticky = sticky;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">//blablabla......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SubscriberMethod</code>类包括订阅类、事件类型、优先级、是否是粘性事件、ThreadMode，将EventBus所需要的全封装起来了。再回到<code>findUsingInfo(subscriberClass)</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;SubscriberMethod&gt; <span class="function"><span class="title">findUsingInfo</span>(<span class="params">Class&lt;?&gt; subscriberClass</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//1.得到一个FindState对象</span></span><br><span class="line">        FindState findState = prepareFindState();</span><br><span class="line">        <span class="comment">//2.subscriberClass赋值给findState</span></span><br><span class="line">        findState.initForSubscriber(subscriberClass);</span><br><span class="line">        <span class="comment">//2.findState的当前class不为null</span></span><br><span class="line">        <span class="keyword">while</span> (findState.clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.默认情况下，getSubscriberInfo()返回的是null</span></span><br><span class="line">            findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">            <span class="comment">//2.那么这个if判断就跳过了</span></span><br><span class="line">            <span class="keyword">if</span> (findState.subscriberInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">                <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                        findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//2.来到了这里,在这个方法中找到了哪些是订阅者订阅的方法和事件：</span></span><br><span class="line">                findUsingReflectionInSingleClass(findState);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3.将当前clazz变为该类的父类，然后再进行while循环的判断</span></span><br><span class="line">            findState.moveToSuperclass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.将findState释放资源，放回复用池中，返回封装好的SubscriberMethod列表</span></span><br><span class="line">        <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总结一下<code>subscriberClass</code>的流程：<br>&emsp;&emsp;1.从复用池中或者new一个，得到<code>findState</code><br>&emsp;&emsp;2.将<code>subscriberClass</code>复制给<code>findState</code><br>&emsp;&emsp;&emsp;&emsp;2.1.进入循环，判断当前<code>clazz</code>为不为<code>null</code><br>&emsp;&emsp;&emsp;&emsp;2.2.不为<code>null</code>的话调用<code>findUsingReflectionInSingleClass()</code>方法得到该类的所有的<code>SubscriberMethod</code><br>&emsp;&emsp;&emsp;&emsp;2.3.将<code>clazz</code>变为<code>clazz</code>的父类，再次进行循环的判断，再去检查父类中是否有订阅方法<br>&emsp;&emsp;3.返回所有的<code>SubscriberMethod</code><br>现在再返回到了<code>findSubscriberMethods()</code>方法中，将所有的<code>SubscriberMethod</code>存储到<code>METHOD_CACHE</code>当中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br></pre></td></tr></table></figure>
<p>再回到<code>EventBus.register()</code>中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">register</span>(<span class="params"><span class="built_in">Object</span> subscriber</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//拿到订阅者的class</span></span><br><span class="line">        Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">        <span class="comment">//通过class去找到订阅方法</span></span><br><span class="line">        List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">        synchronized (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">                <span class="comment">//订阅</span></span><br><span class="line">                subscribe(subscriber, subscriberMethod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>subscriberMethods</code>对象就是一个包含订阅类、事件类型、优先级、是否是粘性事件的集合，接下来遍历这个集合完成订阅。<code>subscribe(subscriber, subscriberMethod)</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>subscriber 注册类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param </span>subscriberMethod 订阅类、事件类型、优先级、是否是粘性事件、ThreadMode的封装对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">subscribe</span>(<span class="params"><span class="built_in">Object</span> subscriber, SubscriberMethod subscriberMethod</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到事件类型</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">    <span class="comment">// 创建Subscription对象,并将 注册类对象 和 订阅方法信息对象(subscriberMethod)保存进去</span></span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">// subscriptionsByEventType:</span></span><br><span class="line">    <span class="comment">// key为事件类型</span></span><br><span class="line">    <span class="comment">// value为该事件类型对应的Subscription(注册类+订阅方法信息)集合</span></span><br><span class="line">    <span class="comment">// 取出eventType对应的List&lt;Subscription&gt;</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果eventType对应的List&lt;Subscription&gt;为null,则创建一个新集合</span></span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 以eventType为key,将新集合put到subscriptionsByEventType中</span></span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若eventType对应的subscriptions(List&lt;Subscription&gt;)不为null</span></span><br><span class="line">        <span class="comment">// 判断subscriptions中是否存在了newSubscription</span></span><br><span class="line">        <span class="comment">// subscribe分析1</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="comment">// 如果存在,抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Subscriber &quot;</span> + subscriber.getClass() + </span><br><span class="line">                                        <span class="string">&quot; already registered to event &quot;</span> + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt;</span><br><span class="line">            subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            <span class="comment">// 根据priority优先级,将newSubscription插入到subscriptions中合适的位置</span></span><br><span class="line">            <span class="comment">// (subscriptions中始终保持priority降序)</span></span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// typesBySubscriber:key为注册类对象;value为该注册类中的事件类型集合</span></span><br><span class="line">    <span class="comment">// 根据注册类获取注册类中所有的事件类型</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果获取到的事件类型为null,则创建一个新集合</span></span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 以注册类对象为key,新建的事件类型集合为value放进typesBySubscriber中</span></span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将eventType(当前订阅方法的订阅事件类型)加入到刚刚新建的集合中</span></span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line">    <span class="comment">//如果是粘性事件</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">            <span class="comment">// eventInheritance还熟悉吧</span></span><br><span class="line">            <span class="comment">// false表示仅将事件对象发送给订阅了自己的订阅者</span></span><br><span class="line">            <span class="comment">// true表示还需要考虑发送给订阅了事件对象父类或接口的订阅者</span></span><br><span class="line">            <span class="comment">// 在postSingleEvent()中也用到了此变量判断</span></span><br><span class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">                <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;Class&lt;?&gt;, <span class="built_in">Object</span>&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">Map</span>.Entry&lt;Class&lt;?&gt;, <span class="built_in">Object</span>&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    <span class="comment">//是否有继承关系</span></span><br><span class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        <span class="built_in">Object</span> stickyEvent = entry.getValue();</span><br><span class="line">                        <span class="comment">// 如果eventType(订阅类型的Class对象)是粘性Map中取出的事件Class对象的父类</span></span><br><span class="line">                        <span class="comment">// 则也需要接收此事件</span></span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 只关心事件对象本身类型就好</span></span><br><span class="line">                <span class="built_in">Object</span> stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注销订阅者"><a href="#注销订阅者" class="headerlink" title="注销订阅者"></a>注销订阅者</h2><p>解除当前类中所有订阅方法对事件的订阅。现在我们来看看<code>unregister()</code>方法的具体实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public synchronized <span class="keyword">void</span> <span class="function"><span class="title">unregister</span>(<span class="params"><span class="built_in">Object</span> subscriber</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 从typesBySubscriber根据注册类对象获取所有的订阅事件类型</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果订阅类型集合不为空,则遍历得到每一个订阅事件类型</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            <span class="comment">// 根据订阅事件类型去subscriptionsByEventType中移除</span></span><br><span class="line">            <span class="comment">// Subscription.subscriber与取消注册的subscriber相同的Subscription</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从typesBySubscriber移除注册类中对应的所有订阅事件类型</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果要解除注册的类中并不存在任何订阅,则打印此log</span></span><br><span class="line">        logger.log(Level.WARNING, <span class="string">&quot;Subscriber to unregister was not </span></span><br><span class="line"><span class="string">        registered before: &quot;</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下<code>unsubscribeByEventType(subscriber, eventType)</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">unsubscribeByEventType</span>(<span class="params"><span class="built_in">Object</span> subscriber, Class&lt;?&gt; eventType</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据订阅事件类型获取到所有的Subscription对象</span></span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="literal">null</span>) &#123;</span><br><span class="line">        int size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="comment">// 即订阅方法所在类的对象 与 解除注册类对象 相同</span></span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                <span class="comment">// 设为非活跃状态</span></span><br><span class="line">                subscription.active = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 从List&lt;Subscription&gt;中移除</span></span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法做的事情就是根据订阅事件类型获取到<code>List&lt;Subscription&gt;</code>，这个集合中的<code>Subscription</code>只保证订阅方法所订阅的事件类型是传入的<code>eventType</code>，但不能就这样把它干掉，还需要判断<code>Subscription</code>是否属于需要解除注册的类，<code>subscription.subscriber == subscriber</code>就是这个作用。一旦满足了这些条件，就可以放心的将<code>Subscription</code>从集合中移除了。前面那段代码则是从<code>typesBySubscriber</code>移除注册类中对应的所有订阅事件类型。</p>
<h2 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h2><p>通过<code>EventBus.post(event)</code>来发送事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">post</span>(<span class="params"><span class="built_in">Object</span> event</span>)</span> &#123;</span><br><span class="line">  	<span class="comment">//1.得到PostingThreadState</span></span><br><span class="line">	PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">	<span class="comment">//blablabla......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>currentPostingThreadState</code>是一个<code>ThreadLocal</code>对象，而<code>ThreadLocal</code>是线程独有，不会与其他线程共享的。其实现是返回一个<code>PostingThreadState</code>对象，而<code>PostingThreadState</code>类的结构是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** For ThreadLocal, much faster to set (and get multiple values). */</span></span><br><span class="line">   <span class="comment">//PostingThreadState 封装的是当前线程的 post 信息，包括事件队列、是否正在分发中、是否在主线程、订阅者信息、事件实例、是否取消</span></span><br><span class="line">   final <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">       final List&lt;<span class="built_in">Object</span>&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       boolean isPosting;</span><br><span class="line">       boolean isMainThread;</span><br><span class="line">       Subscription subscription;</span><br><span class="line">       <span class="built_in">Object</span> event;</span><br><span class="line">       boolean canceled;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>PostingThreadState</code>封装的是当前线程的<code>post</code>信息，包括事件队列、是否正在分发中、是否在主线程、订阅者信息、事件实例、是否取消,回到<code>post()</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">post</span>(<span class="params"><span class="built_in">Object</span> event</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//1.得到PostingThreadState</span></span><br><span class="line">        PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">        <span class="comment">//2.获取其中的队列</span></span><br><span class="line">        List&lt;<span class="built_in">Object</span>&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">        <span class="comment">//2.将该事件添加到队列中</span></span><br><span class="line">        eventQueue.add(event);</span><br><span class="line">        <span class="comment">//2.如果postingState没有进行发送</span></span><br><span class="line">        <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">            <span class="comment">//2. 判断当前线程是否是主线程</span></span><br><span class="line">            postingState.isMainThread = isMainThread();</span><br><span class="line">            <span class="comment">//2.将isPosting状态改为true，表明正在发送中</span></span><br><span class="line">            postingState.isPosting = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//2.如果取消掉了，抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Internal error. Abort state was not reset&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//2.循环，直至队列为空</span></span><br><span class="line">                <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//2.发送事件</span></span><br><span class="line">                    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.isPosting = <span class="literal">false</span>;</span><br><span class="line">                postingState.isMainThread = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后走到一个<code>while</code>循环，判断事件队列是否为空了，如果不为空，继续循环，进行<code>postSingleEvent</code>操作，从事件队列中取出一个事件进行发送。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> postSingleEvent(<span class="built_in">Object</span> event, PostingThreadState postingState) throws <span class="built_in">Error</span> &#123;</span><br><span class="line">        Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">        boolean subscriptionFound = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;<span class="comment">//是否查看事件的继承关系</span></span><br><span class="line">            <span class="comment">//找到事件的所以继承关系的事件类型</span></span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);<span class="comment">// 就是查找该事件的所有父类</span></span><br><span class="line">            int countTypes = eventTypes.size();</span><br><span class="line">            <span class="keyword">for</span> (int h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">                Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">                <span class="comment">//发送事件</span></span><br><span class="line">                subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接发送事件</span></span><br><span class="line">            subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!subscriptionFound) &#123;<span class="comment">//如果没有任何事件</span></span><br><span class="line">            <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">                logger.log(Level.FINE, <span class="string">&quot;No subscribers registered for event &quot;</span> + eventClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                    eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">                <span class="comment">//发送一个NoSubscriberEvent的事件出去</span></span><br><span class="line">                post(<span class="keyword">new</span> NoSubscriberEvent(<span class="built_in">this</span>, event));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>lookupAllEventTypes()</code>就是查找该事件的所有父类，返回所有的该事件的父类的<code>class</code>。它通过循环和递归一起用，将一个类的父类（接口）全部添加到全局静态变量<code>eventTypes</code>集合中。再看一下<code>postSingleEventForEventType</code>方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private boolean <span class="function"><span class="title">postSingleEventForEventType</span>(<span class="params"><span class="built_in">Object</span> event, PostingThreadState postingState, Class&lt;?&gt; eventClass</span>)</span> &#123;</span><br><span class="line">       CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">       synchronized (<span class="built_in">this</span>) &#123;</span><br><span class="line">           <span class="comment">//所有订阅了event的事件集合</span></span><br><span class="line">           subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (subscriptions != <span class="literal">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">               postingState.event = event;</span><br><span class="line">               postingState.subscription = subscription;</span><br><span class="line">               boolean aborted;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//这里调用的postToSubscription方法</span></span><br><span class="line">                   postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                   aborted = postingState.canceled;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   postingState.event = <span class="literal">null</span>;</span><br><span class="line">                   postingState.subscription = <span class="literal">null</span>;</span><br><span class="line">                   postingState.canceled = <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接下来看一下<code>postToSubscription</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">private <span class="keyword">void</span> postToSubscription(Subscription subscription, </span><br><span class="line">                                    <span class="built_in">Object</span> event, boolean isMainThread) &#123;</span><br><span class="line">    <span class="comment">// 获取订阅方法注解信息中的threadMode</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="comment">// POSTING即发送事件在哪个线程,接收事件就在哪个线程</span></span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            <span class="comment">// 因此,直接反射调用</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// MAIN即发送事件时如果在主线程,则直接反射执行订阅方法</span></span><br><span class="line">        <span class="comment">// 否则交给mainThreadPoster处理</span></span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                <span class="comment">// 发送事件时处于主线程</span></span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 发送事件时不处于主线程</span></span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// MAIN_ORDERED即无论发送事件时处于哪个线程,都交由mainThreadPoster处理</span></span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// BACKGROUND即如果发送事件时处于主线程,则交由backgroundPoster处理</span></span><br><span class="line">        <span class="comment">// 否则发送事件时所处的线程,就是订阅方法接收事件时所处的线程</span></span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ASYNC即无论发送事件时处于哪个线程,都交由asyncPoster处理</span></span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unknown thread mode: &quot;</span> + </span><br><span class="line">                            subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深入threadMode"><a href="#深入threadMode" class="headerlink" title="深入threadMode"></a>深入threadMode</h2><p><strong>POSTING</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> POSTING:<span class="comment">//当前线程直接调用</span></span><br><span class="line">     invokeSubscriber(subscription, event);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">invokeSubscriber</span>(<span class="params">Subscription subscription, <span class="built_in">Object</span> event</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//通过反射机制实现方法调用</span></span><br><span class="line">            subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected exception&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，我们就可以得出这样一个结论：<strong>POSTING不会做任何线程切换，接收事件时的线程 = 发送事件时所在的线程。</strong></p>
<p><strong>MAIN</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MAIN即发送事件时如果在主线程,则直接反射执行订阅方法</span></span><br><span class="line"><span class="comment">// 否则交给mainThreadPoster处理</span></span><br><span class="line"><span class="keyword">case</span> MAIN:</span><br><span class="line">    <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">        <span class="comment">// 发送事件时处于主线程</span></span><br><span class="line">        invokeSubscriber(subscription, event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送事件时不处于主线程</span></span><br><span class="line">        mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>首先它判断了发送事件时的线程时否为主线程，如果是则直接反射调用订阅方法，如果不是，则执行了<code>mainThreadPoster.enqueue(subscription, event);</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="title">implements</span> <span class="title">Poster</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 维护着PendingPost(待发送事件与订阅者信息)的队列</span></span><br><span class="line">    private final PendingPostQueue queue;</span><br><span class="line">    private final int maxMillisInsideHandleMessage;</span><br><span class="line">    private final EventBus eventBus;</span><br><span class="line">    <span class="comment">// handleMessage是否正在处理PendingPost</span></span><br><span class="line">    private boolean handlerActive;</span><br><span class="line">    <span class="comment">// HandlerPoster在EventBus创建时便会创建</span></span><br><span class="line">    protected HandlerPoster(EventBus eventBus, Looper looper, </span><br><span class="line">                                    int maxMillisInsideHandleMessage) &#123;</span><br><span class="line">        <span class="comment">// 调用了public Handler(Looper looper)</span></span><br><span class="line">        <span class="built_in">super</span>(looper);</span><br><span class="line">        <span class="built_in">this</span>.eventBus = eventBus;</span><br><span class="line">        <span class="built_in">this</span>.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage;</span><br><span class="line">        queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">enqueue</span>(<span class="params">Subscription subscription, <span class="built_in">Object</span> event</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 得到PendingPost对象</span></span><br><span class="line">        PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">        synchronized (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 将PendingPost对象加入到PendingPostQueue队列中</span></span><br><span class="line">            queue.enqueue(pendingPost);</span><br><span class="line">            <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">                <span class="comment">// 将标记位设为true,表示handleMessage正在处理PendingPost</span></span><br><span class="line">                handlerActive = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 发送一个Message至MessageQueue</span></span><br><span class="line">                <span class="comment">// 通过looper(MainLooper)使handleMessage被回调在主线程</span></span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">handleMessage</span>(<span class="params">Message msg</span>)</span> &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>enqueue()</code>方法中，首先通过<code>obtainPendingPost()</code>方法得到了<code>PendingPost</code>对象，下面我们先来看看<code>PendingPost</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">final <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</span><br><span class="line">    <span class="comment">// PendingPost对象缓存池</span></span><br><span class="line">    private final <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> ArrayList&lt;PendingPost&gt;();</span><br><span class="line">    <span class="built_in">Object</span> event;</span><br><span class="line">    Subscription subscription;</span><br><span class="line">    PendingPost next;</span><br><span class="line">    private <span class="function"><span class="title">PendingPost</span>(<span class="params"><span class="built_in">Object</span> event, Subscription subscription</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.event = event;</span><br><span class="line">        <span class="built_in">this</span>.subscription = subscription;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> PendingPost <span class="function"><span class="title">obtainPendingPost</span>(<span class="params">Subscription subscription, <span class="built_in">Object</span> event</span>)</span> &#123;</span><br><span class="line">        synchronized (pendingPostPool) &#123;</span><br><span class="line">            int size = pendingPostPool.size();</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若缓存池中有数据,则直接复用缓存池中的对象</span></span><br><span class="line">                PendingPost pendingPost = pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">                pendingPost.event = event;</span><br><span class="line">                pendingPost.subscription = subscription;</span><br><span class="line">                pendingPost.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span> pendingPost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则直接创建一个新的PendingPost对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="function"><span class="title">releasePendingPost</span>(<span class="params">PendingPost pendingPost</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在使用完成后,对PendingPost对象字段置空</span></span><br><span class="line">        pendingPost.event = <span class="literal">null</span>;</span><br><span class="line">        pendingPost.subscription = <span class="literal">null</span>;</span><br><span class="line">        pendingPost.next = <span class="literal">null</span>;</span><br><span class="line">        synchronized (pendingPostPool) &#123;</span><br><span class="line">            <span class="comment">// 防止缓存池无限制增长,因此最大不能超过10000</span></span><br><span class="line">            <span class="keyword">if</span> (pendingPostPool.size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">                <span class="comment">// 将PendingPost对象放入缓存池</span></span><br><span class="line">                pendingPostPool.add(pendingPost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单吧，到这里我们发现<code>EventBus</code>中经常使用对象缓存池，之前的<code>FindState</code>，这里的<code>PendingPost</code>都是如此。<br>继续回到<code>HandlerPoster</code>的<code>enqueue()</code>方法中，得到了<code>PendingPost</code>对象后，会将<code>PendingPost</code>对象加入到<code>PendingPostQueue</code>队列中，下面我们一起来看一看<code>PendingPostQueue</code>的实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package org.greenrobot.eventbus;</span><br><span class="line">final <span class="class"><span class="keyword">class</span> <span class="title">PendingPostQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队列头部引用</span></span><br><span class="line">    private PendingPost head;</span><br><span class="line">    <span class="comment">// 队列尾部引用</span></span><br><span class="line">    private PendingPost tail;</span><br><span class="line">    synchronized <span class="keyword">void</span> <span class="function"><span class="title">enqueue</span>(<span class="params">PendingPost pendingPost</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;null cannot be enqueued&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tail != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若队列存在尾部,则将尾部的next引用指向当前pendingPost</span></span><br><span class="line">            tail.next = pendingPost;</span><br><span class="line">            <span class="comment">// 将tail更新为当前pendingPost</span></span><br><span class="line">            tail = pendingPost;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若不存在尾部,也不存在头部,则将当前pendingPost当做头部也当做尾部</span></span><br><span class="line">            head = tail = pendingPost;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Head present, but no tail&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized PendingPost <span class="function"><span class="title">poll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 队列先进先出,取出头部PendingPost对象</span></span><br><span class="line">        PendingPost pendingPost = head;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                tail = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pendingPost;</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            wait(maxMillisToWait);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PendingPostQueue</code>中包含了入队与出队的方法，都很简单。将<code>PendingPost</code>加入到队列中后，执行了<code>sendMessage(obtainMessage())</code>，这个时候，<code>HandlerPoster</code>中的<code>handleMessage()</code>方法就会被回调，又由于<code>looper</code>是<code>MainLooper</code>，因此它是被回调在主线程的，这样也就完成了线程切换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="title">implements</span> <span class="title">Poster</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 维护着PendingPost(待发送事件与订阅者信息)的队列</span></span><br><span class="line">    private final PendingPostQueue queue;</span><br><span class="line">    private final int maxMillisInsideHandleMessage;</span><br><span class="line">    private final EventBus eventBus;</span><br><span class="line">    <span class="comment">// handleMessage是否正在处理PendingPost</span></span><br><span class="line">    private boolean handlerActive;</span><br><span class="line">    <span class="comment">// HandlerPoster在EventBus创建时便会创建</span></span><br><span class="line">    protected HandlerPoster(EventBus eventBus, Looper looper, </span><br><span class="line">                                int maxMillisInsideHandleMessage) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">enqueue</span>(<span class="params">Subscription subscription, <span class="built_in">Object</span> event</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> <span class="function"><span class="title">handleMessage</span>(<span class="params">Message msg</span>)</span> &#123;</span><br><span class="line">        boolean rescheduled = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            long started = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">// 不断从PendingPostQueue中取出PendingPost</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                PendingPost pendingPost = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                    synchronized (<span class="built_in">this</span>) &#123;</span><br><span class="line">                        <span class="comment">// 再次尝试出列</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="literal">null</span>) &#123;</span><br><span class="line">                            handlerActive = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 调用eventBus中的invokeSubscriber</span></span><br><span class="line">                <span class="comment">// 作用是回收pendingPost对象并反射调用订阅方法</span></span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">                long timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">                <span class="comment">// 当时间超出了maxMillisInsideHandleMessage(默认是10)</span></span><br><span class="line">                <span class="comment">// 会重新发一条消息</span></span><br><span class="line">                <span class="comment">// 至于有什么用,目前不太清楚.</span></span><br><span class="line">                <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">&quot;Could not send handler message&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    rescheduled = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            handlerActive = rescheduled;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在<code>handleMessage()</code>中会不停地从<code>PendingPostQueue</code>中取出<code>PendingPost</code>，交给<code>EventBus</code>的<code>invokeSubscriber</code>执行订阅方法的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">invokeSubscriber</span>(<span class="params">PendingPost pendingPost</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 事件对象</span></span><br><span class="line">    <span class="built_in">Object</span> event = pendingPost.event;</span><br><span class="line">    <span class="comment">// 订阅者信息对象</span></span><br><span class="line">    Subscription subscription = pendingPost.subscription;</span><br><span class="line">    <span class="comment">// PendingPost成员置空</span></span><br><span class="line">    PendingPost.releasePendingPost(pendingPost);</span><br><span class="line">    <span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">        <span class="comment">// 反射调用订阅方法</span></span><br><span class="line">        invokeSubscriber(subscription, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，一切都结束了。这就是<code>EventBus</code>为何能够切换线程的奥秘所在。</p>
<p><strong>MAIN_ORDERED</strong><br>MAIN_ORDERED也就没什么可说的了，它只不过是无论发送事件时处于哪个线程，都会统一交由<code>mainThreadPoster</code>处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MAIN_ORDERED即无论发送事件时处于哪个线程,都交由mainThreadPoster处理</span></span><br><span class="line">        <span class="keyword">case</span> MAIN_ORDERED:</span><br><span class="line">            <span class="keyword">if</span> (mainThreadPoster != <span class="literal">null</span>) &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><strong>BACKGROUND与ASYNC</strong><br>有了上面的基础以后，大家可以自行查看BackgroundPoster.java和AsyncPoster.java，在这里简单说明一下：<code>BackgroundPoster</code>会开启一个新的线程来处理队列中的事件；<code>AsyncPoster</code>会为每个事件单独开启一个新的子线程来处理。</p>
<h2 id="EventBus的postSticky"><a href="#EventBus的postSticky" class="headerlink" title="EventBus的postSticky"></a>EventBus的postSticky</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> <span class="function"><span class="title">postSticky</span>(<span class="params"><span class="built_in">Object</span> event</span>)</span> &#123;</span><br><span class="line">    synchronized (stickyEvents) &#123;</span><br><span class="line">        <span class="comment">// 以事件Class对象为key,事件对象本身为value保存</span></span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Should be posted after it is putted, in case the subscriber wants to remove immediately</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只不过在执行正常<code>post</code>流程之前，先将事件对象保存到了<code>stickyEvents</code>这个<code>Map</code>中。现在我们要回到<code>register()</code>方法看一下相关部分的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">            <span class="comment">// eventInheritance还熟悉吧</span></span><br><span class="line">            <span class="comment">// false表示仅将事件对象发送给订阅了自己的订阅者</span></span><br><span class="line">            <span class="comment">// true表示还需要考虑发送给订阅了事件对象父类或接口的订阅者</span></span><br><span class="line">            <span class="comment">// 在postSingleEvent()中也用到了此变量判断</span></span><br><span class="line">            <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">                <span class="built_in">Set</span>&lt;<span class="built_in">Map</span>.Entry&lt;Class&lt;?&gt;, <span class="built_in">Object</span>&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">Map</span>.Entry&lt;Class&lt;?&gt;, <span class="built_in">Object</span>&gt; entry : entries) &#123;</span><br><span class="line">                    Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                    <span class="comment">//是否有继承关系</span></span><br><span class="line">                    <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                        <span class="built_in">Object</span> stickyEvent = entry.getValue();</span><br><span class="line">                        <span class="comment">// 如果eventType(订阅类型的Class对象)是粘性Map中取出的事件Class对象的父类</span></span><br><span class="line">                        <span class="comment">// 则也需要接收此事件</span></span><br><span class="line">                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 只关心事件对象本身类型就好</span></span><br><span class="line">                <span class="built_in">Object</span> stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">                checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private <span class="keyword">void</span> <span class="function"><span class="title">checkPostStickyEventToSubscription</span>(<span class="params">Subscription newSubscription, <span class="built_in">Object</span> stickyEvent</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stickyEvent != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">            <span class="comment">// --&gt; Strange corner case, which we don&#x27;t take care of here.</span></span><br><span class="line">            postToSubscription(newSubscription, stickyEvent, isMainThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结整体流程"><a href="#总结整体流程" class="headerlink" title="总结整体流程"></a>总结整体流程</h2><p><strong>1. getDefault():</strong><br>&emsp;&emsp;通过单例模式获取到EventBus对象，且在创建对象时完成初始化工作。其中两个重要的Map要注意：<code>subscriptionsByEventType、typesBySubscriber</code>。<br>&emsp;&emsp;<strong>typesBySubscriber</strong>:<code>key</code>值是订阅类，<code>value</code>值是该订阅类中所有订阅事件类型的<code>List</code>。<br>&emsp;&emsp;<strong>subscriptionsByEventType</strong>:<code>key</code>值是订阅事件类型(即订阅方法参数类型)，<code>value</code>值是<code>List&lt;Subscription&gt;</code>，其中<code>Subscription</code>是将订阅类和<code>SubscriberMethod</code>订阅方法封装类(包括Method、eventType、threadMode、sticky等)。<br><strong>2. regist():</strong><br>&emsp;&emsp;<strong>2.1.</strong> 先从缓存中判断该注册类有该注册类的信息，有则返回<code>List&lt;SubscriberMethod&gt;</code>；若没有，则通过反射获取该类所有方法，并通过判断修饰符、参数个数（1个）、注释等条件确定订阅方法，然后解析订阅方法信息并封装成<code>SubscriberMethod</code>,如果有父类也对父类信息做如上处理，最后返回一个订阅类及订阅方法信息集合<code>List&lt;SubscriberMethod&gt;</code>（重要）。<br>&emsp;&emsp;<strong>2.2.</strong> 遍历上面的<code>List&lt;SubscriberMethod&gt;</code>，将订阅类、订阅方法、事件类型、即关键分装数据分别放入<code>subscriptionsByEventType、typesBySubscriber</code>中。<br><strong>3. post():</strong><br>&emsp;&emsp;<strong>3.1.</strong> 先将发送的事件保存到队列中，再循环取出调用postSingleEvent<br>&emsp;&emsp;<strong>3.2.</strong> 调用postSingleEvent，开始发送事件，根据事件类型找出所有相关类（父类），开始遍历返回的事件类型集合调用postSingleEventForEventType，通过事件类型，找到<br>&emsp;&emsp;<strong>3.3.</strong> 调用postSingleEventForEventType，通过事件类型，从<code>subscriptionsByEventType</code>中找到<code>List&lt;Subscription&gt;</code>,然后遍历集合调用postToSubscription<br>&emsp;&emsp;<strong>3.3.</strong> 调用postToSubscription，先判断threadMode类型，再进行处理，如POSTING：则直接调用通过放射invoke调用到订阅方法；如MAIN，则先判断是否在主线程，如在主线程则直接调用通过放射invoke调用到订阅方法，如不在主线程，则先通过Handler完成线程切换，在调用invoke。<br><strong>4. unregist():</strong><br>&emsp;&emsp;先通过订阅类从<code>typesBySubscriber</code>中获取该订阅类中所有订阅事件类型的<code>List</code>，并遍历这个集合通过订阅事件类型来获取订阅类和<code>SubscriberMethod</code>订阅方法封装类集合B，再遍历集合B,判断是否和当前需要注销的订阅类相同，若相同则移除item，最后移除<code>typesBySubscriber</code>中的item。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><strong>如MainActivity extend BaseActivity，为什么EventBus.getDefault().register(this)方法无论写在父类还是子类的onCreate都可以生效？</strong><br><code>EventBus.getDefault().register(this),无论写在父类还是子类的onCreate中其实是一样的，this实例都是MainActivity，所以两个都可以生效</code></p>
<p><strong>如果父类中存在与子类相同的订阅方法，方法名、参数类型都相同，为什么父类中的订阅方法失效？</strong><br><code>仔细阅读上文注册订阅者一栏，boolean checkAdd(Method method, Class&lt;?&gt; eventType)方法</code></p>
<p><strong>两个订阅方法如onMessageEvent(Man event)和onMessageEvent(Preson event),其中Man是Person的子类，post（new Man()）,为什么两个订阅方法都会被调用到？</strong><br><code>仔细阅读上午发送事件一栏， List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass)部分的代码</code></p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2020/11/10/Java-Annotation/" data-toggle="tooltip" data-placement="top" title="Java Annotation">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2020/07/30/多线程应用实例/" data-toggle="tooltip" data-placement="top" title="多线程应用实例">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Java" title="Java">Java</a>
                        
                          <a class="tag" href="/tags/#Android" title="Android">Android</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>




<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "hexo-theme-huxblog";
    var disqus_identifier = "https://j-a-g.github.io/2020/09/01/EventBus-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/";
    var disqus_url = "https://j-a-g.github.io/2020/09/01/EventBus-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; JAG&#39;s Blog 2022 
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="https://github.com/Kaijun/hexo-theme-huxblog">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a target="_blank" rel="noopener" href="https://github.com/J-a-g/J-a-g.github.io">JAG</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=J-a-g&J-a-g.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://j-a-g.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<img src="https://j-a-g.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
